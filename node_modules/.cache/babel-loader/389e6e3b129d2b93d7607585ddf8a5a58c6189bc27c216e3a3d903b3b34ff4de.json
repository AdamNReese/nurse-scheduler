{"ast":null,"code":"export const Shift = {\n  DAY: 'day',\n  NIGHT: 'night'\n};\nexport const PreferenceLevel = {\n  PREFER: 'prefer',\n  NEUTRAL: 'neutral',\n  AVOID: 'avoid'\n};\nexport class Nurse {\n  constructor(name, hireDate, dayShiftPreference, nightShiftPreference, weekendPreference) {\n    this.name = name;\n    this.hireDate = new Date(hireDate);\n    this.dayShiftPreference = dayShiftPreference;\n    this.nightShiftPreference = nightShiftPreference;\n    this.weekendPreference = weekendPreference;\n    if (this.hireDate > new Date()) {\n      throw new Error('Hire date cannot be in the future');\n    }\n  }\n  get seniorityYears() {\n    const today = new Date();\n    const diffTime = today - this.hireDate;\n    return diffTime / (1000 * 60 * 60 * 24 * 365.25);\n  }\n}\nexport class ScheduleSlot {\n  constructor(date, shift, nurses = []) {\n    this.date = new Date(date);\n    this.shift = shift;\n    this.nurses = nurses;\n  }\n  get isWeekend() {\n    return this.date.getDay() === 0 || this.date.getDay() === 6; // Sunday = 0, Saturday = 6\n  }\n}\nexport class NurseScheduler {\n  constructor(nurses) {\n    this.nurses = nurses;\n    this.minNursesPerShift = 3;\n    this.maxNursesPerShift = 5;\n  }\n  generateSchedule(startDate, numDays) {\n    const schedule = [];\n\n    // Create all schedule slots\n    for (let day = 0; day < numDays; day++) {\n      const currentDate = new Date(startDate);\n      currentDate.setDate(startDate.getDate() + day);\n      schedule.push(new ScheduleSlot(currentDate, Shift.DAY));\n      schedule.push(new ScheduleSlot(currentDate, Shift.NIGHT));\n    }\n\n    // Assign nurses to shifts\n    this._assignShifts(schedule);\n    return schedule;\n  }\n  _assignShifts(schedule) {\n    const nightShifts = schedule.filter(slot => slot.shift === Shift.NIGHT);\n    const dayShifts = schedule.filter(slot => slot.shift === Shift.DAY);\n    this._assignNightShifts(nightShifts);\n    this._assignDayShifts(dayShifts);\n  }\n  _assignNightShifts(nightShifts) {\n    // Sort nurses by night shift preference (prefer first), then by seniority (newest first)\n    const nightPreferenceOrder = [...this.nurses].sort((a, b) => {\n      if (a.nightShiftPreference === PreferenceLevel.PREFER && b.nightShiftPreference !== PreferenceLevel.PREFER) return -1;\n      if (b.nightShiftPreference === PreferenceLevel.PREFER && a.nightShiftPreference !== PreferenceLevel.PREFER) return 1;\n      if (a.nightShiftPreference === PreferenceLevel.AVOID && b.nightShiftPreference !== PreferenceLevel.AVOID) return 1;\n      if (b.nightShiftPreference === PreferenceLevel.AVOID && a.nightShiftPreference !== PreferenceLevel.AVOID) return -1;\n      return a.seniorityYears - b.seniorityYears; // Lower seniority (newer) first\n    });\n\n    // Track nurse assignments across all shifts\n    const nurseAssignments = {};\n    this.nurses.forEach(nurse => {\n      nurseAssignments[nurse.name] = 0;\n    });\n    nightShifts.forEach(slot => {\n      this._assignNursesToShift(slot, nightPreferenceOrder, nurseAssignments);\n    });\n  }\n  _assignDayShifts(dayShifts) {\n    const dayPreferenceOrder = [...this.nurses].sort((a, b) => {\n      if (a.dayShiftPreference === PreferenceLevel.PREFER && b.dayShiftPreference !== PreferenceLevel.PREFER) return -1;\n      if (b.dayShiftPreference === PreferenceLevel.PREFER && a.dayShiftPreference !== PreferenceLevel.PREFER) return 1;\n      if (a.dayShiftPreference === PreferenceLevel.AVOID && b.dayShiftPreference !== PreferenceLevel.AVOID) return 1;\n      if (b.dayShiftPreference === PreferenceLevel.AVOID && a.dayShiftPreference !== PreferenceLevel.AVOID) return -1;\n      return a.seniorityYears - b.seniorityYears; // Lower seniority (newer) first\n    });\n\n    // Track nurse assignments across all shifts\n    const nurseAssignments = {};\n    this.nurses.forEach(nurse => {\n      nurseAssignments[nurse.name] = 0;\n    });\n    dayShifts.forEach(slot => {\n      this._assignNursesToShift(slot, dayPreferenceOrder, nurseAssignments);\n    });\n  }\n  _assignNursesToShift(slot, preferenceOrder, nurseAssignments) {\n    const targetNurses = Math.min(this.maxNursesPerShift, Math.max(this.minNursesPerShift, Math.floor(this.nurses.length / 2)));\n    const assignedNurses = [];\n    const availableNurses = [...preferenceOrder];\n    while (assignedNurses.length < targetNurses && availableNurses.length > 0) {\n      const nurse = this._findBestNurseForSlot(slot, availableNurses, nurseAssignments);\n      if (nurse) {\n        assignedNurses.push(nurse);\n        nurseAssignments[nurse.name]++;\n        // Remove nurse from available list to prevent double assignment to same shift\n        const index = availableNurses.indexOf(nurse);\n        availableNurses.splice(index, 1);\n      } else {\n        break;\n      }\n    }\n    slot.nurses = assignedNurses;\n  }\n  _findBestNurseForSlot(slot, preferenceOrder, nurseAssignments) {\n    // Sort by current assignment count (fewer assignments first) and then by preference order\n    const sortedNurses = [...preferenceOrder].sort((a, b) => {\n      const aAssignments = nurseAssignments[a.name] || 0;\n      const bAssignments = nurseAssignments[b.name] || 0;\n      if (aAssignments !== bAssignments) {\n        return aAssignments - bAssignments;\n      }\n      return preferenceOrder.indexOf(a) - preferenceOrder.indexOf(b);\n    });\n    for (const nurse of sortedNurses) {\n      if (this._isNurseAvailable(nurse, slot)) {\n        if (slot.isWeekend && nurse.weekendPreference === PreferenceLevel.AVOID) {\n          continue;\n        }\n        return nurse;\n      }\n    }\n    return null;\n  }\n  _isNurseAvailable(nurse, slot) {\n    // Check if nurse is already assigned to this slot\n    if (slot.nurses.includes(nurse)) {\n      return false;\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["Shift","DAY","NIGHT","PreferenceLevel","PREFER","NEUTRAL","AVOID","Nurse","constructor","name","hireDate","dayShiftPreference","nightShiftPreference","weekendPreference","Date","Error","seniorityYears","today","diffTime","ScheduleSlot","date","shift","nurses","isWeekend","getDay","NurseScheduler","minNursesPerShift","maxNursesPerShift","generateSchedule","startDate","numDays","schedule","day","currentDate","setDate","getDate","push","_assignShifts","nightShifts","filter","slot","dayShifts","_assignNightShifts","_assignDayShifts","nightPreferenceOrder","sort","a","b","nurseAssignments","forEach","nurse","_assignNursesToShift","dayPreferenceOrder","preferenceOrder","targetNurses","Math","min","max","floor","length","assignedNurses","availableNurses","_findBestNurseForSlot","index","indexOf","splice","sortedNurses","aAssignments","bAssignments","_isNurseAvailable","includes"],"sources":["/Users/adamreese/code/scheduler/nurse-scheduler-app/src/scheduler.js"],"sourcesContent":["export const Shift = {\n  DAY: 'day',\n  NIGHT: 'night'\n};\n\nexport const PreferenceLevel = {\n  PREFER: 'prefer',\n  NEUTRAL: 'neutral',\n  AVOID: 'avoid'\n};\n\nexport class Nurse {\n  constructor(name, hireDate, dayShiftPreference, nightShiftPreference, weekendPreference) {\n    this.name = name;\n    this.hireDate = new Date(hireDate);\n    this.dayShiftPreference = dayShiftPreference;\n    this.nightShiftPreference = nightShiftPreference;\n    this.weekendPreference = weekendPreference;\n    \n    if (this.hireDate > new Date()) {\n      throw new Error('Hire date cannot be in the future');\n    }\n  }\n\n  get seniorityYears() {\n    const today = new Date();\n    const diffTime = today - this.hireDate;\n    return diffTime / (1000 * 60 * 60 * 24 * 365.25);\n  }\n}\n\nexport class ScheduleSlot {\n  constructor(date, shift, nurses = []) {\n    this.date = new Date(date);\n    this.shift = shift;\n    this.nurses = nurses;\n  }\n\n  get isWeekend() {\n    return this.date.getDay() === 0 || this.date.getDay() === 6; // Sunday = 0, Saturday = 6\n  }\n}\n\nexport class NurseScheduler {\n  constructor(nurses) {\n    this.nurses = nurses;\n    this.minNursesPerShift = 3;\n    this.maxNursesPerShift = 5;\n  }\n\n  generateSchedule(startDate, numDays) {\n    const schedule = [];\n    \n    // Create all schedule slots\n    for (let day = 0; day < numDays; day++) {\n      const currentDate = new Date(startDate);\n      currentDate.setDate(startDate.getDate() + day);\n      \n      schedule.push(new ScheduleSlot(currentDate, Shift.DAY));\n      schedule.push(new ScheduleSlot(currentDate, Shift.NIGHT));\n    }\n    \n    // Assign nurses to shifts\n    this._assignShifts(schedule);\n    \n    return schedule;\n  }\n\n  _assignShifts(schedule) {\n    const nightShifts = schedule.filter(slot => slot.shift === Shift.NIGHT);\n    const dayShifts = schedule.filter(slot => slot.shift === Shift.DAY);\n    \n    this._assignNightShifts(nightShifts);\n    this._assignDayShifts(dayShifts);\n  }\n\n  _assignNightShifts(nightShifts) {\n    // Sort nurses by night shift preference (prefer first), then by seniority (newest first)\n    const nightPreferenceOrder = [...this.nurses].sort((a, b) => {\n      if (a.nightShiftPreference === PreferenceLevel.PREFER && b.nightShiftPreference !== PreferenceLevel.PREFER) return -1;\n      if (b.nightShiftPreference === PreferenceLevel.PREFER && a.nightShiftPreference !== PreferenceLevel.PREFER) return 1;\n      if (a.nightShiftPreference === PreferenceLevel.AVOID && b.nightShiftPreference !== PreferenceLevel.AVOID) return 1;\n      if (b.nightShiftPreference === PreferenceLevel.AVOID && a.nightShiftPreference !== PreferenceLevel.AVOID) return -1;\n      return a.seniorityYears - b.seniorityYears; // Lower seniority (newer) first\n    });\n\n    // Track nurse assignments across all shifts\n    const nurseAssignments = {};\n    this.nurses.forEach(nurse => {\n      nurseAssignments[nurse.name] = 0;\n    });\n\n    nightShifts.forEach(slot => {\n      this._assignNursesToShift(slot, nightPreferenceOrder, nurseAssignments);\n    });\n  }\n\n  _assignDayShifts(dayShifts) {\n    const dayPreferenceOrder = [...this.nurses].sort((a, b) => {\n      if (a.dayShiftPreference === PreferenceLevel.PREFER && b.dayShiftPreference !== PreferenceLevel.PREFER) return -1;\n      if (b.dayShiftPreference === PreferenceLevel.PREFER && a.dayShiftPreference !== PreferenceLevel.PREFER) return 1;\n      if (a.dayShiftPreference === PreferenceLevel.AVOID && b.dayShiftPreference !== PreferenceLevel.AVOID) return 1;\n      if (b.dayShiftPreference === PreferenceLevel.AVOID && a.dayShiftPreference !== PreferenceLevel.AVOID) return -1;\n      return a.seniorityYears - b.seniorityYears; // Lower seniority (newer) first\n    });\n\n    // Track nurse assignments across all shifts\n    const nurseAssignments = {};\n    this.nurses.forEach(nurse => {\n      nurseAssignments[nurse.name] = 0;\n    });\n\n    dayShifts.forEach(slot => {\n      this._assignNursesToShift(slot, dayPreferenceOrder, nurseAssignments);\n    });\n  }\n\n  _assignNursesToShift(slot, preferenceOrder, nurseAssignments) {\n    const targetNurses = Math.min(\n      this.maxNursesPerShift,\n      Math.max(this.minNursesPerShift, Math.floor(this.nurses.length / 2))\n    );\n\n    const assignedNurses = [];\n    const availableNurses = [...preferenceOrder];\n\n    while (assignedNurses.length < targetNurses && availableNurses.length > 0) {\n      const nurse = this._findBestNurseForSlot(slot, availableNurses, nurseAssignments);\n      if (nurse) {\n        assignedNurses.push(nurse);\n        nurseAssignments[nurse.name]++;\n        // Remove nurse from available list to prevent double assignment to same shift\n        const index = availableNurses.indexOf(nurse);\n        availableNurses.splice(index, 1);\n      } else {\n        break;\n      }\n    }\n\n    slot.nurses = assignedNurses;\n  }\n\n  _findBestNurseForSlot(slot, preferenceOrder, nurseAssignments) {\n    // Sort by current assignment count (fewer assignments first) and then by preference order\n    const sortedNurses = [...preferenceOrder].sort((a, b) => {\n      const aAssignments = nurseAssignments[a.name] || 0;\n      const bAssignments = nurseAssignments[b.name] || 0;\n      if (aAssignments !== bAssignments) {\n        return aAssignments - bAssignments;\n      }\n      return preferenceOrder.indexOf(a) - preferenceOrder.indexOf(b);\n    });\n\n    for (const nurse of sortedNurses) {\n      if (this._isNurseAvailable(nurse, slot)) {\n        if (slot.isWeekend && nurse.weekendPreference === PreferenceLevel.AVOID) {\n          continue;\n        }\n        return nurse;\n      }\n    }\n    return null;\n  }\n\n  _isNurseAvailable(nurse, slot) {\n    // Check if nurse is already assigned to this slot\n    if (slot.nurses.includes(nurse)) {\n      return false;\n    }\n    return true;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}